# 题目
设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

    push(x) —— 将元素 x 推入栈中。
    pop() —— 删除栈顶的元素。
    top() —— 获取栈顶元素。
    getMin() —— 检索栈中的最小元素。

 

示例:

输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.

 

提示：

    pop、top 和 getMin 操作总是在 非空栈 上调用。

* 代码1：不用栈结构
    ```C++
    class MinStack {
    public:
        /** initialize your data structure here. */
        vector<int> data;
        int minnum;
        MinStack() {
            minnum = INT_MAX;
        }
        
        void push(int x) {
            data.push_back(x);
            minnum = min(x,minnum);
        }
        
        void pop() {
            int tmp = data.back();
            data.erase(data.end()-1);
            if(tmp==minnum)
            {
                minnum = INT_MAX;
                for(int n=0;n<data.size();++n)
                {
                    minnum = min(minnum,data[n]);
                }
            }
        }
        int top() {
            return data.back();
        }
        
        int getMin() {
            return minnum;
        }
    };
    ```
* 代码2：O(1)时间复杂度，使用栈结构
    ```C++
    class MinStack {
    public:
        /** initialize your data structure here. */
        stack<int> data;
        stack<int> mindata;
        MinStack() {
            mindata.push(INT_MAX);
        }
        
        void push(int x) {
            data.push(x);
            mindata.push(min(x,mindata.top()));
        }
        
        void pop() {
            data.pop();
            mindata.pop();
        }
        int top() {
            return data.top();   
        }
        
        int getMin() {
            return mindata.top();
        }
    };
    ```