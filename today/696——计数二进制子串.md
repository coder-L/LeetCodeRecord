# 题目
给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。

重复出现的子串要计算它们出现的次数。

* 实例：

>输入: "00110011"<br>
输出: 6<br>
解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。<br>
请注意，一些重复出现的子串要计算它们出现的次数。<br>
另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。

>输入: "10101"<br>
输出: 4<br>
解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。

注意：

    s.length 在1到50,000之间。
    s 只包含“0”或“1”字符。

* 思路：有更好的方法

* 代码：
    ```C++
    class Solution {
    public:
        int countBinarySubstrings(string s) {
            int length = s.size();
            if(length==0)
            {
                return 0;
            }
            vector<int> dp(length,0);
            dp[0]=1;
            int result = 0;
            for(int n=1;n<length;++n)
            {
                if(s[n]==s[n-1])
                {
                    dp[n] = dp[n-1]+1;
                    if(n-dp[n-1]-1>0 && dp[n-dp[n-1]-1]>=dp[n])
                    {
                        ++result;
                    }
                }
                else
                {
                    ++result;
                    dp[n]=1;
                }
            }
            return result;
        }
    };
    ```