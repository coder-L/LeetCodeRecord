# 题目
爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。

最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：

    选出任一 x，满足 0 < x < N 且 N % x == 0 。
    用 N - x 替换黑板上的数字 N 。

如果玩家无法执行这些操作，就会输掉游戏。

只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。

* 示例：
>输入：2<br>
输出：true<br>
解释：爱丽丝选择 1，鲍勃无法进行操作。

>输入：3<br>
输出：false<br>
解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。


* 思路1：动态规划

* 代码：
    ```C++
    class Solution {
    public:
        bool divisorGame(int N) {
            vector<bool> dp(N+1,false);
            for(int n=2;n<=N;++n)
            {
                for(int m=1;m<n;++m)
                {
                    if(n%m==0 && dp[n-m]==false)
                    {
                        dp[n]=true;
                    }
                }
            }
            return dp[N];

        }
    };
    ```

* 思路2：奇数输，偶数赢，可用数学归纳法证明。
    1. N=1时假设成立，N=2时假设成立，假设N<=k时假设成立，则当N=k+1时，有
        1. 如果k为偶数，则k+1为奇数，设x为k+1的因子，则x必为奇数，则k+1-x为偶数，且小于等于k，有N<=k时假设成立，则k+1为奇数时必输
        2. 如果k为奇数，则k+1为偶数，因子x可以为奇数也可以为偶数（至少有1和2），则选择奇数的因子x，k+1-x为奇数，且小于等于k，则k+1为偶数必赢

* 代码2：
    ```C++
    class Solution {
    public:
        bool divisorGame(int N) {
            return N%2==0;
        }
    };
    ```