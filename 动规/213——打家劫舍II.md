# 题目

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

* 示例:
>输入: [2,3,2]<br>
输出: 3<br>
解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。

>输入: [1,2,3,1]<br>
输出: 4<br>
解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。<br>
偷窃到的最高金额 = 1 + 3 = 4 。

* 思路：动态规划，将问题分成两个子问题，如果包含第一间房子的偷法则不可能偷最后一间房子，相当于最后一间房子不存在，如果包含最后一间房子的偷法，则不可能偷第一间房子，相当于第一间房子不存在。因此将问题拆为两部分，1到n-1所能得到的最大值，2到n所能得到的最大值，最后两者取较大值即为结果
    1. dp[n]=max(dp[n-1],nums[n]+dp[n-2])


* 代码：
    ```C++
    class Solution {
    public:
        int rob(vector<int>& nums) {
            int length = nums.size();
            if(length==0)
            {
                return 0;
            }
            if(length==1)
            {
                return nums[0];
            }
            vector<int> dp1(length,0);
            vector<int> dp2(length,0);
            dp1[1]=nums[0];//dp1从第一间房子开始偷到倒数第二间房子
            dp2[1]=nums[1];//dp2从第二间房子开始偷到最后一间房子
            int result=max(dp1[1],dp2[1]);
            for(int n=1;n<length-1;++n)
            {
                dp1[n+1]=max(dp1[n],dp1[n-1]+nums[n]);
                dp2[n+1]=max(dp2[n],dp2[n-1]+nums[n+1]);
                result = max(result,max(dp1[n+1],dp2[n+1]));
            }
            return result;
        }
    };
    ```