# 题目
给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个位置。

* 示例:

输入: [2,3,1,1,4]
输出: true
解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。

示例 2:

输入: [3,2,1,0,4]
输出: false
解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。

* 思路1：贪心，从后向前遍历数组，则从倒数第二个格子跳到最后一个格子只需要一步，初始化dis为1，表示第二个格子只需要一步就可以到达最后一个格子，如果倒数第二个格子可以走>=1步，则倒数第三个格子只需要1步到达倒数第二个格子就可以确保能到达最后一个格子，如果倒数第二个格子不能到达最后一个位置，则倒数第三个格子至少需要>=2才能走到最后一个格子，即考虑当前遍历的格子要是想走到最后一个格子所需要的最小步数，如果能到达则将dis置为1，表示前面的一个格子只要能走1步到达当前格子就一定可以到达最后一个格子，否则dis++，统计需要的最小步数。最后比较第一个格子能走的步数和它所需要走的最小的步数，就可以知道它能否到达最后一个格子。

* 代码1：
    ```C++
    class Solution {
    public:
        bool canJump(vector<int> &nums)
        {
            int length = nums.size();
            if(length<2)
            {
                return true;
            }
            int dis=1;
            for(int n=length-2;n>0;--n)
            {
                if(nums[n]>=dis)
                {
                    dis=1;
                }
                else
                {
                    ++dis;
                }
            }
            return nums[0]>=dis;
        }
    };
    ```

* 思路2：贪心，从前到后遍历数组，记录能到达的最远的格子，如果>=最后一个格子，则表示最后一个格子可以到达，否则最后一个格子不能到达。这里是因为一个格子如果能够到达，则这个格子之前的格子一定是可以到达的。
* 代码2：
    ```C++
    class Solution {
    public:
        bool canJump(vector<int>& nums) {
            int length = nums.size();
            int reach = 0;
            for(int n=0;n<length && n<=reach;++n)
            {
                reach = max(reach,n+nums[n]);
                if(reach>=length-1)
                {
                    return true;
                }
            }
            return false;
        }
    };
    ```