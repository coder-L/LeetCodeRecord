# 题目
给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。

* 示例：
>输入：A = [4,5,0,-2,-3,1], K = 5<br>
输出：7<br>
解释：<br>
有 7 个子数组满足其元素之和可被 K = 5 整除：<br>
[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]

* 思路：
    1. 同余，两个和除K余数相同，则两个数组的差可以整除K，因此用map记录以当前元素为结尾的和除K的余数
    2. 当有一个和除K余n时，则这个和可以和之前的任意一个和组成对，得到余数为0，即count=count+map[K]
    3. 如果余数为0，则当前元素本身即为整数K的数，需要将map[0]置为1，其余余数置为0
    4. C++余数问题：C++中-1%2=-1，如果余数小于了则将余数+K，再放入map中
* 代码：
    ```C++
    class Solution {
    public:
        int subarraysDivByK(vector<int>& A, int K) {
            int count=0;
            unordered_map<int,int> record;
            record[0]=1;
            int sum=0;
            int length = A.size();
            for(int n=0;n<length;++n)
            {
                sum+=A[n];
                int tmp =sum%K;
                tmp = tmp <0?tmp+K:tmp;
                count += record[tmp];
                ++record[tmp];
            }
            return count;
        }
    };
    ```