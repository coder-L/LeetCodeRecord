# 题目

爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：

爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 每次抽取都是独立的，其结果具有相同的概率。

当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？




* 示例：

>输入：N = 10, K = 1, W = 10<br>
输出：1.00000<br>
说明：爱丽丝得到一张卡，然后停止。

>输入：N = 6, K = 1, W = 10<br>
输出：0.60000<br>
说明：爱丽丝得到一张卡，然后停止。<br>
在 W = 10 的 6 种可能下，她的得分不超过 N = 6 分。

>输入：N = 21, K = 17, W = 10<br>
输出：0.73278

* 思路：逆向思维，从最后一次抓拍考虑，当手里分数为K-1时会进行最后一次抓牌，得到的范围是[K,K+W-1]，每一个数的概率是1/W,则判断[K,K+W-1]之前的数有多少小于等于N，则可以得到手里分数为K-1时结果不大于N的概率，继续考虑手里分数为K-2时的情况，K-2时要进行抓牌，可能的范围是[K-1,K+W-2]，每个结果的概率相等，由于[K-1,K+W-2]小于等于N的概率已知，则将其求和，除以W即为手里分数为K-2时不大于N的概率，以此类推。
    1. 令f(x)表示手里分数为x时，最后结果不大于N的概率，则f(x) = (f(x+1)+f(x+2)+...+f(x+W))/W
    2. 优化：因为要每次求和，增加了时间复杂度，以K-1和K-2为例，求和的部分W\*f(K-2) = f(K-1)*W-f(K+W-1)+f(K-1)，可以简化求和的步骤

* 代码：
    ```C++
    class Solution {
    public:
        double new21Game(int N, int K, int W) {
            if (K == 0) {
                return 1.0;
            }
            vector<double> dp(K + W + 1);
            for (int i = K; i <= N && i < K + W; i++) {
                dp[i] = 1.0;
            }
            double sum=0.0;
            for(int i=K;i<K+W;++i)
            {
                sum += dp[i];
            }
            dp[K-1] = sum / (double) W;
            for (int i = K - 2; i >= 0; i--) {
                dp[i] = (dp[i+1]*W-dp[i+W+1]+dp[i+1])/(double) W;
            }
            return dp[0];
        }
    };
    ```